/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : testDefault_sm.sm
 */

#include "TestDefault.h"
#include "testDefault_sm.h"

using namespace statemap;

// Static class declarations.
init_Waiting init::Waiting("init::Waiting", 0);
maintenance_Maintenance maintenance::Maintenance("maintenance::Maintenance", 1);

void TestDefaultState::goBack(testDefaultContext& context)
{
    Default(context);
    return;
}

void TestDefaultState::goMaintenance(testDefaultContext& context)
{
    Default(context);
    return;
}

void TestDefaultState::waiting(testDefaultContext& context)
{
    Default(context);
    return;
}

void TestDefaultState::Default(testDefaultContext& context)
{
    if (context.getDebugFlag() == true)
    {
        TRACE("TRANSITION   : Default\n\r");
    }

    throw (
        TransitionUndefinedException(
            context.getState().getName(),
            context.getTransition()));

    return;
}

void init_Default::goMaintenance(testDefaultContext& context)
{
    TestDefault& ctxt(context.getOwner());

    if (context.getDebugFlag() == true)
    {
        TRACE("LEAVING STATE   : init::Default\n\r");
    }

    if ( ctxt.displayState() )
    {
        TestDefaultState& endState = context.getState();

        if (context.getDebugFlag() == true)
        {
            TRACE("ENTER TRANSITION: init::Default::goMaintenance()\n\r");
        }

        context.clearState();
        try
        {
            ctxt.say("go to maintenance");
            if (context.getDebugFlag() == true)
            {
                TRACE("EXIT TRANSITION : init::Default::goMaintenance()\n\r");
            }

            context.setState(endState);
            context.pushState(maintenance::Maintenance);
        }
        catch (...)
        {
            context.setState(endState);
            context.pushState(maintenance::Maintenance);
            throw;
        }
        (context.getState()).Entry(context);
    }
    else
    {
         init_Default::goMaintenance(context);
    }

    return;
}

void init_Waiting::waiting(testDefaultContext& context)
{
    TestDefault& ctxt(context.getOwner());

    if (context.getDebugFlag() == true)
    {
        TRACE("LEAVING STATE   : init::Waiting\n\r");
    }

    TestDefaultState& endState = context.getState();

    if (context.getDebugFlag() == true)
    {
        TRACE("ENTER TRANSITION: init::Waiting::waiting()\n\r");
    }

    context.clearState();
    try
    {
        ctxt.say("stay here");
        if (context.getDebugFlag() == true)
        {
            TRACE("EXIT TRANSITION : init::Waiting::waiting()\n\r");
        }

        context.setState(endState);
    }
    catch (...)
    {
        context.setState(endState);
        throw;
    }

    return;
}

void maintenance_Maintenance::goBack(testDefaultContext& context)
{
    TestDefault& ctxt(context.getOwner());

    if (context.getDebugFlag() == true)
    {
        TRACE("LEAVING STATE   : maintenance::Maintenance\n\r");
    }

    (context.getState()).Exit(context);
    if (context.getDebugFlag() == true)
    {
        TRACE("ENTER TRANSITION: maintenance::Maintenance::goBack()\n\r");
    }

    context.clearState();
    try
    {
        ctxt.say("back to main");
        if (context.getDebugFlag() == true)
        {
            TRACE("EXIT TRANSITION : maintenance::Maintenance::goBack()\n\r");
        }

        context.popState();
    }
    catch (...)
    {
        context.popState();
        throw;
    }

    return;
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
